<!DOCTYPE html>
<html>
<head>
    <title>Hill Climb Racing Prototype (Matter.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; }
        canvas { display: block; background-color: #79a647; /* Green terrain */ }
    </style>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // Matter.js Aliases
        const Engine = Matter.Engine,
              Render = Matter.Render,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Constraint = Matter.Constraint,
              Composite = Matter.Composite;

        // ----------------------------------------------------
        // 1. ENGINE AND RENDER SETUP
        // ----------------------------------------------------

        // Create a Matter.js engine
        const engine = Engine.create();
        const world = engine.world;

        // Set up the renderer (attaches to the document body)
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false, // Set to true to see the physics boundaries
                background: '#87CEEB' // Sky color
            }
        });

        Render.run(render);

        // Run the engine
        const runner = Matter.Runner.create();
        Matter.Runner.run(runner, engine);
        
        // Disable gravity on X-axis (no side drift)
        world.gravity.x = 0;
        // Normal gravity on Y-axis
        world.gravity.y = 1; 

        // ----------------------------------------------------
        // 2. TERRAIN GENERATION (The Hills)
        // ----------------------------------------------------
        
        const segmentCount = 100; // Number of terrain segments
        const segmentWidth = 100; 
        const terrainHeightOffset = 50; // Starting height
        const terrainYJitter = 100; // Max height variation

        let points = [];
        let lastY = window.innerHeight - terrainHeightOffset;
        
        // Generate a series of points for the hilly terrain
        for (let i = 0; i < segmentCount; i++) {
            points.push({ x: i * segmentWidth, y: lastY });
            
            // Randomly adjust the next point's height
            let newY = lastY + (Math.random() - 0.5) * terrainYJitter;
            // Keep the terrain generally on the lower half of the screen
            lastY = Math.max(window.innerHeight - 300, newY); 
        }

        // Create ground segments (thin static rectangles between the points)
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];

            // Calculate center and angle of the segment
            const center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Create the ground segment (static body)
            const ground = Bodies.rectangle(center.x, center.y, length, 20, {
                isStatic: true,
                angle: angle,
                friction: 0.9, // High friction for grip
                render: { fillStyle: '#444' } // Dark gray color for ground
            });

            World.add(world, ground);
        }
        
        // ----------------------------------------------------
        // 3. VEHICLE CONSTRUCTION (The Car)
        // ----------------------------------------------------

        const vehicle = {};
        const wheelRadius = 25;
        const carX = 150;
        const carY = window.innerHeight - 200;

        // Chassis (A simple rectangle)
        vehicle.body = Bodies.rectangle(carX, carY - 20, 80, 25, { 
            density: 0.001, // Light body
            friction: 0.1,
            render: { fillStyle: 'red' }
        });

        // Front Wheel
        vehicle.front = Bodies.circle(carX + 40, carY, wheelRadius, { 
            friction: 0.9, 
            label: 'wheel',
            render: { fillStyle: 'black' } 
        });

        // Rear Wheel
        vehicle.rear = Bodies.circle(carX - 40, carY, wheelRadius, { 
            friction: 0.9, 
            label: 'wheel',
            render: { fillStyle: 'black' } 
        });

        // Constraints (Springs connecting the wheels to the chassis)
        const stiffness = 0.5; // Controls the "springiness" of the suspension

        vehicle.frontAxle = Constraint.create({
            bodyB: vehicle.front,
            pointA: { x: 40, y: 0 },
            pointB: { x: 0, y: 0 },
            bodyA: vehicle.body,
            stiffness: stiffness
        });

        vehicle.rearAxle = Constraint.create({
            bodyB: vehicle.rear,
            pointA: { x: -40, y: 0 },
            pointB: { x: 0, y: 0 },
            bodyA: vehicle.body,
            stiffness: stiffness
        });

        // Add the car components to the world
        Composite.add(world, [
            vehicle.body, 
            vehicle.front, 
            vehicle.rear, 
            vehicle.frontAxle, 
            vehicle.rearAxle
        ]);


        // ----------------------------------------------------
        // 4. CONTROLS AND MOVEMENT
        // ----------------------------------------------------
        
        const maxForce = 0.005; // Power of the engine

        document.addEventListener('keydown', function(event) {
            switch (event.key) {
                case 'ArrowRight': // Gas (Apply angular force to the wheels)
                    Matter.Body.setAngularVelocity(vehicle.front, maxForce);
                    Matter.Body.setAngularVelocity(vehicle.rear, maxForce);
                    break;
                case 'ArrowLeft': // Brake / Reverse (Apply negative angular force)
                    Matter.Body.setAngularVelocity(vehicle.front, -maxForce / 2); // Slower reverse
                    Matter.Body.setAngularVelocity(vehicle.rear, -maxForce / 2);
                    break;
                case 'ArrowUp': // Tilt forward (for flips)
                    Matter.Body.applyForce(vehicle.body, vehicle.body.position, { x: 0.0, y: -0.015 });
                    break;
                case 'ArrowDown': // Tilt backward
                    Matter.Body.applyForce(vehicle.body, vehicle.body.position, { x: 0.0, y: 0.015 });
                    break;
            }
        });
        
        // ----------------------------------------------------
        // 5. CAMERA FOLLOW
        // ----------------------------------------------------

        Matter.Events.on(engine, 'beforeUpdate', function() {
            // Calculate the camera position (center the view on the car's body)
            const targetX = vehicle.body.position.x;
            const targetY = vehicle.body.position.y;
            
            // Camera Pan (smoothly move the view)
            const offsetX = targetX - render.options.width / 2;
            const offsetY = targetY - render.options.height / 2;

            // Update the camera view translation
            Render.lookAt(render, { 
                min: { x: offsetX - 50, y: offsetY - 50 }, 
                max: { x: offsetX + render.options.width + 50, y: offsetY + render.options.height + 50 }
            });
        });


    </script>
</body>
</html>